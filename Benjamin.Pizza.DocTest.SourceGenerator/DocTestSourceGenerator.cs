using System.Text.RegularExpressions;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Benjamin.Pizza.DocTest.SourceGenerator;

/// <summary>
/// Source generator for doctests.
/// </summary>
public class DocTestSourceGenerator : IIncrementalGenerator
{
    private static readonly Regex _outputRegex = new(@"// Output:\s*", RegexOptions.Compiled);
    private static readonly Regex _commentRegex = new(@"^\s*(//( |$))?", RegexOptions.Compiled);

#pragma warning disable RS2008  // Enable analyzer release tracking
    private static readonly DiagnosticDescriptor _missingDocFile
        = new(
            "DOCTEST0001",
            "Missing XML documentation file",
            "Add an AdditionalFiles item for {0}",
            "DocTest",
            DiagnosticSeverity.Error,
            true
        );

    private static readonly DiagnosticDescriptor _mustBePublic
        = new(
            "DOCTEST0002",
            "Class must be public",
            "Mark {0} as public",
            "DocTest",
            DiagnosticSeverity.Error,
            true
        );

    private static readonly DiagnosticDescriptor _mustBePartial
        = new(
            "DOCTEST0003",
            "Class must be partial",
            "Mark {0} as partial",
            "DocTest",
            DiagnosticSeverity.Error,
            true
        );
#pragma warning restore RS2008  // Enable analyzer release tracking

    /// <summary>
    /// Initialise the source generator.
    /// </summary>
    /// <param name="context">The context.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblies = context.SyntaxProvider.ForAttributeWithMetadataName(
            "Benjamin.Pizza.DocTest.DocTestAttribute",
            (_, _) => true,
            (ctx, ct) =>
            {
                var clsSyntax = (ClassDeclarationSyntax)ctx.TargetNode;
                var cls = ctx.TargetSymbol;
                var attr = ctx.Attributes.Single();
                var typeInAssembly = (INamedTypeSymbol)attr.ConstructorArguments.Single().Value!;
                return (attr, clsSyntax, cls, asm: typeInAssembly.ContainingAssembly);
            });

        var documentationFiles = assemblies
            .Combine(context.AdditionalTextsProvider.Where(x => Path.GetExtension(x.Path) == ".xml").Collect())
            .Select((tup, ct) => (
                attr: tup.Left.attr,
                clsSyntax: tup.Left.clsSyntax,
                cls: tup.Left.cls,
                docPath: tup.Left.asm.Identity.Name + ".xml",
                doc: tup.Right
                    .Where(x => Path.GetFileName(x.Path) == tup.Left.asm.Identity.Name + ".xml")
                    .SingleOrDefault()
            ));

        context.RegisterSourceOutput(
            documentationFiles,
            (ctx, tup) =>
            {
                var attrSyntaxRef = tup.attr.ApplicationSyntaxReference;
                var attrLocation = Location.Create(attrSyntaxRef!.SyntaxTree, attrSyntaxRef.Span);

                if (!tup.clsSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(_mustBePartial, attrLocation, tup.cls.Name));
                    return;
                }

                if (!tup.clsSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)))
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(_mustBePublic, attrLocation, tup.cls.Name));
                    return;
                }

                if (tup.doc == null)
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(_missingDocFile, attrLocation, tup.docPath));
                    return;
                }

                var ns = tup.cls.ContainingNamespace != null
                    ? $"namespace {tup.cls.ContainingNamespace.Name};"
                    : "";

                var source = $$"""
                    // ------------------------------------------------------------------
                    // <auto-generated>
                    //     This code was generated by DocTest.
                    // </auto-generated>
                    // ------------------------------------------------------------------
                    {{ns}}

                    public partial class {{tup.cls.Name}}
                    {
                    {{string.Join("\n", CreateMethods(tup.doc))}}
                    }
                    """;

                ctx.AddSource(tup.cls.Name + ".DocTest.g.cs", source);
            }
        );
    }

    private IEnumerable<string> CreateMethods(AdditionalText doc)
    {
        var xml = XDocument.Parse(doc.GetText()!.ToString());
        return
            from mem in xml.Descendants()
            where mem.Name == "member"
            from ex in mem.Descendants()
            where ex.Name == "example"
            let codes = ex
                .Elements()
                .Where(c => c.Name == "code" && c.Attribute("doctest")?.Value == "true")
                .Select((x, i) => (ix: i, code: x.Value))
            from c in codes
            let name = ex.Attribute("name")!.Value
                + (codes.Count() > 1 ? " > " + c.ix : "")
            select GetMethod(name, c.code);
    }

    private string GetMethod(string name, string code)
    {
        var methodName = GetMethodName(name);
        return $$"""
                [Xunit.Fact]
                public static async Task {{methodName}}()
                {
                    var __doctest_redirector = Benjamin.Pizza.DocTest.DocTestHelper.RedirectConsole();
                    using (__doctest_redirector)
                    {
                        {{code.Trim()}}
                    }

                    Xunit.Assert.Equal("", __doctest_redirector.CapturedConsoleError);

                    Xunit.Assert.Equal(
                        [
                            {{GetExpected(code)}}
                        ],
                        Benjamin.Pizza.DocTest.DocTestHelper.SplitLines(__doctest_redirector.CapturedConsoleOut)
                    );
                }
            """;
    }

    private string GetMethodName(string name)
        => name.Replace(' ', '_');

    private string GetExpected(string code)
    {
        var match = _outputRegex.Match(code);
        return string.Join(
            ",\n                ",
            DocTestHelper
                .SplitLines(code.Substring(match.Index + match.Length))
                .Select(line => SyntaxFactory.Literal(_commentRegex.Replace(line, "")))
        );
    }
}
